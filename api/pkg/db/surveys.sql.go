// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: surveys.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSurvey = `-- name: CreateSurvey :one
INSERT INTO surveys
(parse_status, delivery_status, error_log, name, config, url_slug)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, uuid, created_at, parse_status, delivery_status, error_log, name, url_slug, config
`

type CreateSurveyParams struct {
	ParseStatus    NullSurveyParseStatuses
	DeliveryStatus NullSurveyDeliveryStatuses
	ErrorLog       pgtype.Text
	Name           string
	Config         []byte
	UrlSlug        string
}

func (q *Queries) CreateSurvey(ctx context.Context, arg CreateSurveyParams) (Survey, error) {
	row := q.db.QueryRow(ctx, createSurvey,
		arg.ParseStatus,
		arg.DeliveryStatus,
		arg.ErrorLog,
		arg.Name,
		arg.Config,
		arg.UrlSlug,
	)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.ParseStatus,
		&i.DeliveryStatus,
		&i.ErrorLog,
		&i.Name,
		&i.UrlSlug,
		&i.Config,
	)
	return i, err
}

const getSurveys = `-- name: GetSurveys :many
SELECT id, uuid, created_at, parse_status, delivery_status, error_log, name, url_slug, config
FROM surveys
ORDER BY id DESC
`

func (q *Queries) GetSurveys(ctx context.Context) ([]Survey, error) {
	rows, err := q.db.Query(ctx, getSurveys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Survey
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.CreatedAt,
			&i.ParseStatus,
			&i.DeliveryStatus,
			&i.ErrorLog,
			&i.Name,
			&i.UrlSlug,
			&i.Config,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
